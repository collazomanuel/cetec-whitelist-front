import {
  FormElement
} from "./chunk-YVRBNKK2.js";
import {
  ifDefined
} from "./chunk-7HFWFKW7.js";
import {
  observer
} from "./chunk-LZB3YDLX.js";
import {
  BaseElement,
  Directive,
  MDCFoundation,
  PartType,
  __assign,
  __decorate,
  __extends,
  __values,
  addHasRemoveClass,
  classMap,
  directive
} from "./chunk-K3OMBPZJ.js";
import "./chunk-U67UUIIQ.js";
import {
  customElement,
  eventOptions,
  property,
  query,
  state
} from "./chunk-T7WKPCUD.js";
import {
  _$LH,
  html,
  noChange,
  nothing
} from "./chunk-IUEDBVQM.js";
import "./chunk-KTZKXPFA.js";

// node_modules/@material/notched-outline/constants.js
var strings = {
  NOTCH_ELEMENT_SELECTOR: ".mdc-notched-outline__notch"
};
var numbers = {
  NOTCH_ELEMENT_PADDING: 8
};
var cssClasses = {
  NO_LABEL: "mdc-notched-outline--no-label",
  OUTLINE_NOTCHED: "mdc-notched-outline--notched",
  OUTLINE_UPGRADED: "mdc-notched-outline--upgraded"
};

// node_modules/@material/notched-outline/foundation.js
var MDCNotchedOutlineFoundation = function(_super) {
  __extends(MDCNotchedOutlineFoundation2, _super);
  function MDCNotchedOutlineFoundation2(adapter) {
    return _super.call(this, __assign(__assign({}, MDCNotchedOutlineFoundation2.defaultAdapter), adapter)) || this;
  }
  Object.defineProperty(MDCNotchedOutlineFoundation2, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCNotchedOutlineFoundation2, "cssClasses", {
    get: function() {
      return cssClasses;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCNotchedOutlineFoundation2, "numbers", {
    get: function() {
      return numbers;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCNotchedOutlineFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        setNotchWidthProperty: function() {
          return void 0;
        },
        removeNotchWidthProperty: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCNotchedOutlineFoundation2.prototype.notch = function(notchWidth) {
    var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation2.cssClasses.OUTLINE_NOTCHED;
    if (notchWidth > 0) {
      notchWidth += numbers.NOTCH_ELEMENT_PADDING;
    }
    this.adapter.setNotchWidthProperty(notchWidth);
    this.adapter.addClass(OUTLINE_NOTCHED);
  };
  MDCNotchedOutlineFoundation2.prototype.closeNotch = function() {
    var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation2.cssClasses.OUTLINE_NOTCHED;
    this.adapter.removeClass(OUTLINE_NOTCHED);
    this.adapter.removeNotchWidthProperty();
  };
  return MDCNotchedOutlineFoundation2;
}(MDCFoundation);

// node_modules/@material/mwc-notched-outline/mwc-notched-outline-base.js
var NotchedOutlineBase = class extends BaseElement {
  constructor() {
    super(...arguments);
    this.mdcFoundationClass = MDCNotchedOutlineFoundation;
    this.width = 0;
    this.open = false;
    this.lastOpen = this.open;
  }
  createAdapter() {
    return {
      addClass: (className) => this.mdcRoot.classList.add(className),
      removeClass: (className) => this.mdcRoot.classList.remove(className),
      setNotchWidthProperty: (width) => this.notchElement.style.setProperty("width", `${width}px`),
      removeNotchWidthProperty: () => this.notchElement.style.removeProperty("width")
    };
  }
  openOrClose(shouldOpen, width) {
    if (!this.mdcFoundation) {
      return;
    }
    if (shouldOpen && width !== void 0) {
      this.mdcFoundation.notch(width);
    } else {
      this.mdcFoundation.closeNotch();
    }
  }
  render() {
    this.openOrClose(this.open, this.width);
    const classes = classMap({
      "mdc-notched-outline--notched": this.open
    });
    return html`
      <span class="mdc-notched-outline ${classes}">
        <span class="mdc-notched-outline__leading"></span>
        <span class="mdc-notched-outline__notch">
          <slot></slot>
        </span>
        <span class="mdc-notched-outline__trailing"></span>
      </span>`;
  }
};
__decorate([
  query(".mdc-notched-outline")
], NotchedOutlineBase.prototype, "mdcRoot", void 0);
__decorate([
  property({ type: Number })
], NotchedOutlineBase.prototype, "width", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], NotchedOutlineBase.prototype, "open", void 0);
__decorate([
  query(".mdc-notched-outline__notch")
], NotchedOutlineBase.prototype, "notchElement", void 0);

// node_modules/@material/mwc-notched-outline/mwc-notched-outline.js
import { styles } from "/home/euge/Documentos/Pasant\xEDa/Chatbot/Lista Blanca/whitelist-front/node_modules/@material/mwc-notched-outline/mwc-notched-outline.css.js";
var NotchedOutline = class NotchedOutline2 extends NotchedOutlineBase {
};
NotchedOutline.styles = [styles];
NotchedOutline = __decorate([
  customElement("mwc-notched-outline")
], NotchedOutline);

// node_modules/@material/floating-label/constants.js
var cssClasses2 = {
  LABEL_FLOAT_ABOVE: "mdc-floating-label--float-above",
  LABEL_REQUIRED: "mdc-floating-label--required",
  LABEL_SHAKE: "mdc-floating-label--shake",
  ROOT: "mdc-floating-label"
};

// node_modules/@material/floating-label/foundation.js
var MDCFloatingLabelFoundation = function(_super) {
  __extends(MDCFloatingLabelFoundation2, _super);
  function MDCFloatingLabelFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCFloatingLabelFoundation2.defaultAdapter), adapter)) || this;
    _this.shakeAnimationEndHandler = function() {
      _this.handleShakeAnimationEnd();
    };
    return _this;
  }
  Object.defineProperty(MDCFloatingLabelFoundation2, "cssClasses", {
    get: function() {
      return cssClasses2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFloatingLabelFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        getWidth: function() {
          return 0;
        },
        registerInteractionHandler: function() {
          return void 0;
        },
        deregisterInteractionHandler: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCFloatingLabelFoundation2.prototype.init = function() {
    this.adapter.registerInteractionHandler("animationend", this.shakeAnimationEndHandler);
  };
  MDCFloatingLabelFoundation2.prototype.destroy = function() {
    this.adapter.deregisterInteractionHandler("animationend", this.shakeAnimationEndHandler);
  };
  MDCFloatingLabelFoundation2.prototype.getWidth = function() {
    return this.adapter.getWidth();
  };
  MDCFloatingLabelFoundation2.prototype.shake = function(shouldShake) {
    var LABEL_SHAKE = MDCFloatingLabelFoundation2.cssClasses.LABEL_SHAKE;
    if (shouldShake) {
      this.adapter.addClass(LABEL_SHAKE);
    } else {
      this.adapter.removeClass(LABEL_SHAKE);
    }
  };
  MDCFloatingLabelFoundation2.prototype.float = function(shouldFloat) {
    var _a2 = MDCFloatingLabelFoundation2.cssClasses, LABEL_FLOAT_ABOVE = _a2.LABEL_FLOAT_ABOVE, LABEL_SHAKE = _a2.LABEL_SHAKE;
    if (shouldFloat) {
      this.adapter.addClass(LABEL_FLOAT_ABOVE);
    } else {
      this.adapter.removeClass(LABEL_FLOAT_ABOVE);
      this.adapter.removeClass(LABEL_SHAKE);
    }
  };
  MDCFloatingLabelFoundation2.prototype.setRequired = function(isRequired) {
    var LABEL_REQUIRED = MDCFloatingLabelFoundation2.cssClasses.LABEL_REQUIRED;
    if (isRequired) {
      this.adapter.addClass(LABEL_REQUIRED);
    } else {
      this.adapter.removeClass(LABEL_REQUIRED);
    }
  };
  MDCFloatingLabelFoundation2.prototype.handleShakeAnimationEnd = function() {
    var LABEL_SHAKE = MDCFloatingLabelFoundation2.cssClasses.LABEL_SHAKE;
    this.adapter.removeClass(LABEL_SHAKE);
  };
  return MDCFloatingLabelFoundation2;
}(MDCFoundation);

// node_modules/@material/mwc-floating-label/mwc-floating-label-directive.js
var createAdapter = (labelElement) => {
  return {
    addClass: (className) => labelElement.classList.add(className),
    removeClass: (className) => labelElement.classList.remove(className),
    getWidth: () => labelElement.scrollWidth,
    registerInteractionHandler: (evtType, handler) => {
      labelElement.addEventListener(evtType, handler);
    },
    deregisterInteractionHandler: (evtType, handler) => {
      labelElement.removeEventListener(evtType, handler);
    }
  };
};
var FloatingLabelDirective = class extends Directive {
  constructor(partInfo) {
    super(partInfo);
    this.foundation = null;
    this.previousPart = null;
    switch (partInfo.type) {
      case PartType.ATTRIBUTE:
      case PartType.PROPERTY:
        break;
      default:
        throw new Error("FloatingLabel directive only support attribute and property parts");
    }
  }
  update(part, [label]) {
    if (part !== this.previousPart) {
      if (this.foundation) {
        this.foundation.destroy();
      }
      this.previousPart = part;
      const labelElement = part.element;
      labelElement.classList.add("mdc-floating-label");
      const adapter = createAdapter(labelElement);
      this.foundation = new MDCFloatingLabelFoundation(adapter);
      this.foundation.init();
    }
    return this.render(label);
  }
  render(_label) {
    return this.foundation;
  }
};
var floatingLabel = directive(FloatingLabelDirective);

// node_modules/@material/line-ripple/constants.js
var cssClasses3 = {
  LINE_RIPPLE_ACTIVE: "mdc-line-ripple--active",
  LINE_RIPPLE_DEACTIVATING: "mdc-line-ripple--deactivating"
};

// node_modules/@material/line-ripple/foundation.js
var MDCLineRippleFoundation = function(_super) {
  __extends(MDCLineRippleFoundation2, _super);
  function MDCLineRippleFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCLineRippleFoundation2.defaultAdapter), adapter)) || this;
    _this.transitionEndHandler = function(evt) {
      _this.handleTransitionEnd(evt);
    };
    return _this;
  }
  Object.defineProperty(MDCLineRippleFoundation2, "cssClasses", {
    get: function() {
      return cssClasses3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCLineRippleFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        setStyle: function() {
          return void 0;
        },
        registerEventHandler: function() {
          return void 0;
        },
        deregisterEventHandler: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCLineRippleFoundation2.prototype.init = function() {
    this.adapter.registerEventHandler("transitionend", this.transitionEndHandler);
  };
  MDCLineRippleFoundation2.prototype.destroy = function() {
    this.adapter.deregisterEventHandler("transitionend", this.transitionEndHandler);
  };
  MDCLineRippleFoundation2.prototype.activate = function() {
    this.adapter.removeClass(cssClasses3.LINE_RIPPLE_DEACTIVATING);
    this.adapter.addClass(cssClasses3.LINE_RIPPLE_ACTIVE);
  };
  MDCLineRippleFoundation2.prototype.setRippleCenter = function(xCoordinate) {
    this.adapter.setStyle("transform-origin", xCoordinate + "px center");
  };
  MDCLineRippleFoundation2.prototype.deactivate = function() {
    this.adapter.addClass(cssClasses3.LINE_RIPPLE_DEACTIVATING);
  };
  MDCLineRippleFoundation2.prototype.handleTransitionEnd = function(evt) {
    var isDeactivating = this.adapter.hasClass(cssClasses3.LINE_RIPPLE_DEACTIVATING);
    if (evt.propertyName === "opacity") {
      if (isDeactivating) {
        this.adapter.removeClass(cssClasses3.LINE_RIPPLE_ACTIVE);
        this.adapter.removeClass(cssClasses3.LINE_RIPPLE_DEACTIVATING);
      }
    }
  };
  return MDCLineRippleFoundation2;
}(MDCFoundation);

// node_modules/@material/mwc-line-ripple/mwc-line-ripple-directive.js
var createAdapter2 = (lineElement) => {
  return {
    addClass: (className) => lineElement.classList.add(className),
    removeClass: (className) => lineElement.classList.remove(className),
    hasClass: (className) => lineElement.classList.contains(className),
    setStyle: (propertyName, value) => lineElement.style.setProperty(propertyName, value),
    registerEventHandler: (evtType, handler) => {
      lineElement.addEventListener(evtType, handler);
    },
    deregisterEventHandler: (evtType, handler) => {
      lineElement.removeEventListener(evtType, handler);
    }
  };
};
var LineRippleDirective = class extends Directive {
  constructor(partInfo) {
    super(partInfo);
    this.previousPart = null;
    this.foundation = null;
    switch (partInfo.type) {
      case PartType.ATTRIBUTE:
      case PartType.PROPERTY:
        return;
      default:
        throw new Error("LineRipple only support attribute and property parts.");
    }
  }
  update(part, _params) {
    if (this.previousPart !== part) {
      if (this.foundation) {
        this.foundation.destroy();
      }
      this.previousPart = part;
      const lineElement = part.element;
      lineElement.classList.add("mdc-line-ripple");
      const adapter = createAdapter2(lineElement);
      this.foundation = new MDCLineRippleFoundation(adapter);
      this.foundation.init();
    }
    return this.render();
  }
  render() {
    return this.foundation;
  }
};
var lineRipple = directive(LineRippleDirective);

// node_modules/@material/textfield/constants.js
var strings2 = {
  ARIA_CONTROLS: "aria-controls",
  ARIA_DESCRIBEDBY: "aria-describedby",
  INPUT_SELECTOR: ".mdc-text-field__input",
  LABEL_SELECTOR: ".mdc-floating-label",
  LEADING_ICON_SELECTOR: ".mdc-text-field__icon--leading",
  LINE_RIPPLE_SELECTOR: ".mdc-line-ripple",
  OUTLINE_SELECTOR: ".mdc-notched-outline",
  PREFIX_SELECTOR: ".mdc-text-field__affix--prefix",
  SUFFIX_SELECTOR: ".mdc-text-field__affix--suffix",
  TRAILING_ICON_SELECTOR: ".mdc-text-field__icon--trailing"
};
var cssClasses4 = {
  DISABLED: "mdc-text-field--disabled",
  FOCUSED: "mdc-text-field--focused",
  HELPER_LINE: "mdc-text-field-helper-line",
  INVALID: "mdc-text-field--invalid",
  LABEL_FLOATING: "mdc-text-field--label-floating",
  NO_LABEL: "mdc-text-field--no-label",
  OUTLINED: "mdc-text-field--outlined",
  ROOT: "mdc-text-field",
  TEXTAREA: "mdc-text-field--textarea",
  WITH_LEADING_ICON: "mdc-text-field--with-leading-icon",
  WITH_TRAILING_ICON: "mdc-text-field--with-trailing-icon",
  WITH_INTERNAL_COUNTER: "mdc-text-field--with-internal-counter"
};
var numbers2 = {
  LABEL_SCALE: 0.75
};
var VALIDATION_ATTR_WHITELIST = [
  "pattern",
  "min",
  "max",
  "required",
  "step",
  "minlength",
  "maxlength"
];
var ALWAYS_FLOAT_TYPES = [
  "color",
  "date",
  "datetime-local",
  "month",
  "range",
  "time",
  "week"
];

// node_modules/@material/textfield/foundation.js
var POINTERDOWN_EVENTS = ["mousedown", "touchstart"];
var INTERACTION_EVENTS = ["click", "keydown"];
var MDCTextFieldFoundation = function(_super) {
  __extends(MDCTextFieldFoundation2, _super);
  function MDCTextFieldFoundation2(adapter, foundationMap) {
    if (foundationMap === void 0) {
      foundationMap = {};
    }
    var _this = _super.call(this, __assign(__assign({}, MDCTextFieldFoundation2.defaultAdapter), adapter)) || this;
    _this.isFocused = false;
    _this.receivedUserInput = false;
    _this.valid = true;
    _this.useNativeValidation = true;
    _this.validateOnValueChange = true;
    _this.helperText = foundationMap.helperText;
    _this.characterCounter = foundationMap.characterCounter;
    _this.leadingIcon = foundationMap.leadingIcon;
    _this.trailingIcon = foundationMap.trailingIcon;
    _this.inputFocusHandler = function() {
      _this.activateFocus();
    };
    _this.inputBlurHandler = function() {
      _this.deactivateFocus();
    };
    _this.inputInputHandler = function() {
      _this.handleInput();
    };
    _this.setPointerXOffset = function(evt) {
      _this.setTransformOrigin(evt);
    };
    _this.textFieldInteractionHandler = function() {
      _this.handleTextFieldInteraction();
    };
    _this.validationAttributeChangeHandler = function(attributesList) {
      _this.handleValidationAttributeChange(attributesList);
    };
    return _this;
  }
  Object.defineProperty(MDCTextFieldFoundation2, "cssClasses", {
    get: function() {
      return cssClasses4;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2, "strings", {
    get: function() {
      return strings2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2, "numbers", {
    get: function() {
      return numbers2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldAlwaysFloat", {
    get: function() {
      var type = this.getNativeInput().type;
      return ALWAYS_FLOAT_TYPES.indexOf(type) >= 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldFloat", {
    get: function() {
      return this.shouldAlwaysFloat || this.isFocused || !!this.getValue() || this.isBadInput();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldShake", {
    get: function() {
      return !this.isFocused && !this.isValid() && !!this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return true;
        },
        setInputAttr: function() {
          return void 0;
        },
        removeInputAttr: function() {
          return void 0;
        },
        registerTextFieldInteractionHandler: function() {
          return void 0;
        },
        deregisterTextFieldInteractionHandler: function() {
          return void 0;
        },
        registerInputInteractionHandler: function() {
          return void 0;
        },
        deregisterInputInteractionHandler: function() {
          return void 0;
        },
        registerValidationAttributeChangeHandler: function() {
          return new MutationObserver(function() {
            return void 0;
          });
        },
        deregisterValidationAttributeChangeHandler: function() {
          return void 0;
        },
        getNativeInput: function() {
          return null;
        },
        isFocused: function() {
          return false;
        },
        activateLineRipple: function() {
          return void 0;
        },
        deactivateLineRipple: function() {
          return void 0;
        },
        setLineRippleTransformOrigin: function() {
          return void 0;
        },
        shakeLabel: function() {
          return void 0;
        },
        floatLabel: function() {
          return void 0;
        },
        setLabelRequired: function() {
          return void 0;
        },
        hasLabel: function() {
          return false;
        },
        getLabelWidth: function() {
          return 0;
        },
        hasOutline: function() {
          return false;
        },
        notchOutline: function() {
          return void 0;
        },
        closeOutline: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCTextFieldFoundation2.prototype.init = function() {
    var e_1, _a2, e_2, _b2;
    if (this.adapter.hasLabel() && this.getNativeInput().required) {
      this.adapter.setLabelRequired(true);
    }
    if (this.adapter.isFocused()) {
      this.inputFocusHandler();
    } else if (this.adapter.hasLabel() && this.shouldFloat) {
      this.notchOutline(true);
      this.adapter.floatLabel(true);
      this.styleFloating(true);
    }
    this.adapter.registerInputInteractionHandler("focus", this.inputFocusHandler);
    this.adapter.registerInputInteractionHandler("blur", this.inputBlurHandler);
    this.adapter.registerInputInteractionHandler("input", this.inputInputHandler);
    try {
      for (var POINTERDOWN_EVENTS_1 = __values(POINTERDOWN_EVENTS), POINTERDOWN_EVENTS_1_1 = POINTERDOWN_EVENTS_1.next(); !POINTERDOWN_EVENTS_1_1.done; POINTERDOWN_EVENTS_1_1 = POINTERDOWN_EVENTS_1.next()) {
        var evtType = POINTERDOWN_EVENTS_1_1.value;
        this.adapter.registerInputInteractionHandler(evtType, this.setPointerXOffset);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (POINTERDOWN_EVENTS_1_1 && !POINTERDOWN_EVENTS_1_1.done && (_a2 = POINTERDOWN_EVENTS_1.return))
          _a2.call(POINTERDOWN_EVENTS_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    try {
      for (var INTERACTION_EVENTS_1 = __values(INTERACTION_EVENTS), INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next(); !INTERACTION_EVENTS_1_1.done; INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next()) {
        var evtType = INTERACTION_EVENTS_1_1.value;
        this.adapter.registerTextFieldInteractionHandler(evtType, this.textFieldInteractionHandler);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (INTERACTION_EVENTS_1_1 && !INTERACTION_EVENTS_1_1.done && (_b2 = INTERACTION_EVENTS_1.return))
          _b2.call(INTERACTION_EVENTS_1);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    this.validationObserver = this.adapter.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler);
    this.setcharacterCounter(this.getValue().length);
  };
  MDCTextFieldFoundation2.prototype.destroy = function() {
    var e_3, _a2, e_4, _b2;
    this.adapter.deregisterInputInteractionHandler("focus", this.inputFocusHandler);
    this.adapter.deregisterInputInteractionHandler("blur", this.inputBlurHandler);
    this.adapter.deregisterInputInteractionHandler("input", this.inputInputHandler);
    try {
      for (var POINTERDOWN_EVENTS_2 = __values(POINTERDOWN_EVENTS), POINTERDOWN_EVENTS_2_1 = POINTERDOWN_EVENTS_2.next(); !POINTERDOWN_EVENTS_2_1.done; POINTERDOWN_EVENTS_2_1 = POINTERDOWN_EVENTS_2.next()) {
        var evtType = POINTERDOWN_EVENTS_2_1.value;
        this.adapter.deregisterInputInteractionHandler(evtType, this.setPointerXOffset);
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (POINTERDOWN_EVENTS_2_1 && !POINTERDOWN_EVENTS_2_1.done && (_a2 = POINTERDOWN_EVENTS_2.return))
          _a2.call(POINTERDOWN_EVENTS_2);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    try {
      for (var INTERACTION_EVENTS_2 = __values(INTERACTION_EVENTS), INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next(); !INTERACTION_EVENTS_2_1.done; INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next()) {
        var evtType = INTERACTION_EVENTS_2_1.value;
        this.adapter.deregisterTextFieldInteractionHandler(evtType, this.textFieldInteractionHandler);
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (INTERACTION_EVENTS_2_1 && !INTERACTION_EVENTS_2_1.done && (_b2 = INTERACTION_EVENTS_2.return))
          _b2.call(INTERACTION_EVENTS_2);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
    this.adapter.deregisterValidationAttributeChangeHandler(this.validationObserver);
  };
  MDCTextFieldFoundation2.prototype.handleTextFieldInteraction = function() {
    var nativeInput = this.adapter.getNativeInput();
    if (nativeInput && nativeInput.disabled) {
      return;
    }
    this.receivedUserInput = true;
  };
  MDCTextFieldFoundation2.prototype.handleValidationAttributeChange = function(attributesList) {
    var _this = this;
    attributesList.some(function(attributeName) {
      if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
        _this.styleValidity(true);
        _this.adapter.setLabelRequired(_this.getNativeInput().required);
        return true;
      }
      return false;
    });
    if (attributesList.indexOf("maxlength") > -1) {
      this.setcharacterCounter(this.getValue().length);
    }
  };
  MDCTextFieldFoundation2.prototype.notchOutline = function(openNotch) {
    if (!this.adapter.hasOutline() || !this.adapter.hasLabel()) {
      return;
    }
    if (openNotch) {
      var labelWidth = this.adapter.getLabelWidth() * numbers2.LABEL_SCALE;
      this.adapter.notchOutline(labelWidth);
    } else {
      this.adapter.closeOutline();
    }
  };
  MDCTextFieldFoundation2.prototype.activateFocus = function() {
    this.isFocused = true;
    this.styleFocused(this.isFocused);
    this.adapter.activateLineRipple();
    if (this.adapter.hasLabel()) {
      this.notchOutline(this.shouldFloat);
      this.adapter.floatLabel(this.shouldFloat);
      this.styleFloating(this.shouldFloat);
      this.adapter.shakeLabel(this.shouldShake);
    }
    if (this.helperText && (this.helperText.isPersistent() || !this.helperText.isValidation() || !this.valid)) {
      this.helperText.showToScreenReader();
    }
  };
  MDCTextFieldFoundation2.prototype.setTransformOrigin = function(evt) {
    if (this.isDisabled() || this.adapter.hasOutline()) {
      return;
    }
    var touches = evt.touches;
    var targetEvent = touches ? touches[0] : evt;
    var targetClientRect = targetEvent.target.getBoundingClientRect();
    var normalizedX = targetEvent.clientX - targetClientRect.left;
    this.adapter.setLineRippleTransformOrigin(normalizedX);
  };
  MDCTextFieldFoundation2.prototype.handleInput = function() {
    this.autoCompleteFocus();
    this.setcharacterCounter(this.getValue().length);
  };
  MDCTextFieldFoundation2.prototype.autoCompleteFocus = function() {
    if (!this.receivedUserInput) {
      this.activateFocus();
    }
  };
  MDCTextFieldFoundation2.prototype.deactivateFocus = function() {
    this.isFocused = false;
    this.adapter.deactivateLineRipple();
    var isValid = this.isValid();
    this.styleValidity(isValid);
    this.styleFocused(this.isFocused);
    if (this.adapter.hasLabel()) {
      this.notchOutline(this.shouldFloat);
      this.adapter.floatLabel(this.shouldFloat);
      this.styleFloating(this.shouldFloat);
      this.adapter.shakeLabel(this.shouldShake);
    }
    if (!this.shouldFloat) {
      this.receivedUserInput = false;
    }
  };
  MDCTextFieldFoundation2.prototype.getValue = function() {
    return this.getNativeInput().value;
  };
  MDCTextFieldFoundation2.prototype.setValue = function(value) {
    if (this.getValue() !== value) {
      this.getNativeInput().value = value;
    }
    this.setcharacterCounter(value.length);
    if (this.validateOnValueChange) {
      var isValid = this.isValid();
      this.styleValidity(isValid);
    }
    if (this.adapter.hasLabel()) {
      this.notchOutline(this.shouldFloat);
      this.adapter.floatLabel(this.shouldFloat);
      this.styleFloating(this.shouldFloat);
      if (this.validateOnValueChange) {
        this.adapter.shakeLabel(this.shouldShake);
      }
    }
  };
  MDCTextFieldFoundation2.prototype.isValid = function() {
    return this.useNativeValidation ? this.isNativeInputValid() : this.valid;
  };
  MDCTextFieldFoundation2.prototype.setValid = function(isValid) {
    this.valid = isValid;
    this.styleValidity(isValid);
    var shouldShake = !isValid && !this.isFocused && !!this.getValue();
    if (this.adapter.hasLabel()) {
      this.adapter.shakeLabel(shouldShake);
    }
  };
  MDCTextFieldFoundation2.prototype.setValidateOnValueChange = function(shouldValidate) {
    this.validateOnValueChange = shouldValidate;
  };
  MDCTextFieldFoundation2.prototype.getValidateOnValueChange = function() {
    return this.validateOnValueChange;
  };
  MDCTextFieldFoundation2.prototype.setUseNativeValidation = function(useNativeValidation) {
    this.useNativeValidation = useNativeValidation;
  };
  MDCTextFieldFoundation2.prototype.isDisabled = function() {
    return this.getNativeInput().disabled;
  };
  MDCTextFieldFoundation2.prototype.setDisabled = function(disabled) {
    this.getNativeInput().disabled = disabled;
    this.styleDisabled(disabled);
  };
  MDCTextFieldFoundation2.prototype.setHelperTextContent = function(content) {
    if (this.helperText) {
      this.helperText.setContent(content);
    }
  };
  MDCTextFieldFoundation2.prototype.setLeadingIconAriaLabel = function(label) {
    if (this.leadingIcon) {
      this.leadingIcon.setAriaLabel(label);
    }
  };
  MDCTextFieldFoundation2.prototype.setLeadingIconContent = function(content) {
    if (this.leadingIcon) {
      this.leadingIcon.setContent(content);
    }
  };
  MDCTextFieldFoundation2.prototype.setTrailingIconAriaLabel = function(label) {
    if (this.trailingIcon) {
      this.trailingIcon.setAriaLabel(label);
    }
  };
  MDCTextFieldFoundation2.prototype.setTrailingIconContent = function(content) {
    if (this.trailingIcon) {
      this.trailingIcon.setContent(content);
    }
  };
  MDCTextFieldFoundation2.prototype.setcharacterCounter = function(currentLength) {
    if (!this.characterCounter) {
      return;
    }
    var maxLength = this.getNativeInput().maxLength;
    if (maxLength === -1) {
      throw new Error("MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.");
    }
    this.characterCounter.setCounterValue(currentLength, maxLength);
  };
  MDCTextFieldFoundation2.prototype.isBadInput = function() {
    return this.getNativeInput().validity.badInput || false;
  };
  MDCTextFieldFoundation2.prototype.isNativeInputValid = function() {
    return this.getNativeInput().validity.valid;
  };
  MDCTextFieldFoundation2.prototype.styleValidity = function(isValid) {
    var INVALID = MDCTextFieldFoundation2.cssClasses.INVALID;
    if (isValid) {
      this.adapter.removeClass(INVALID);
    } else {
      this.adapter.addClass(INVALID);
    }
    if (this.helperText) {
      this.helperText.setValidity(isValid);
      var helperTextValidation = this.helperText.isValidation();
      if (!helperTextValidation) {
        return;
      }
      var helperTextVisible = this.helperText.isVisible();
      var helperTextId = this.helperText.getId();
      if (helperTextVisible && helperTextId) {
        this.adapter.setInputAttr(strings2.ARIA_DESCRIBEDBY, helperTextId);
      } else {
        this.adapter.removeInputAttr(strings2.ARIA_DESCRIBEDBY);
      }
    }
  };
  MDCTextFieldFoundation2.prototype.styleFocused = function(isFocused) {
    var FOCUSED = MDCTextFieldFoundation2.cssClasses.FOCUSED;
    if (isFocused) {
      this.adapter.addClass(FOCUSED);
    } else {
      this.adapter.removeClass(FOCUSED);
    }
  };
  MDCTextFieldFoundation2.prototype.styleDisabled = function(isDisabled) {
    var _a2 = MDCTextFieldFoundation2.cssClasses, DISABLED = _a2.DISABLED, INVALID = _a2.INVALID;
    if (isDisabled) {
      this.adapter.addClass(DISABLED);
      this.adapter.removeClass(INVALID);
    } else {
      this.adapter.removeClass(DISABLED);
    }
    if (this.leadingIcon) {
      this.leadingIcon.setDisabled(isDisabled);
    }
    if (this.trailingIcon) {
      this.trailingIcon.setDisabled(isDisabled);
    }
  };
  MDCTextFieldFoundation2.prototype.styleFloating = function(isFloating) {
    var LABEL_FLOATING = MDCTextFieldFoundation2.cssClasses.LABEL_FLOATING;
    if (isFloating) {
      this.adapter.addClass(LABEL_FLOATING);
    } else {
      this.adapter.removeClass(LABEL_FLOATING);
    }
  };
  MDCTextFieldFoundation2.prototype.getNativeInput = function() {
    var nativeInput = this.adapter ? this.adapter.getNativeInput() : null;
    return nativeInput || {
      disabled: false,
      maxLength: -1,
      required: false,
      type: "input",
      validity: {
        badInput: false,
        valid: true
      },
      value: ""
    };
  };
  return MDCTextFieldFoundation2;
}(MDCFoundation);
var foundation_default = MDCTextFieldFoundation;

// node_modules/lit-html/development/directive-helpers.js
var _a;
var _b;
var { _ChildPart: ChildPart } = _$LH;
var ENABLE_SHADYDOM_NOPATCH = true;
var wrap = ENABLE_SHADYDOM_NOPATCH && ((_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) && ((_b = window.ShadyDOM) === null || _b === void 0 ? void 0 : _b.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
var isSingleExpression = (part) => part.strings === void 0;
var RESET_VALUE = {};
var setCommittedValue = (part, value = RESET_VALUE) => part._$committedValue = value;

// node_modules/lit-html/development/directives/live.js
var LiveDirective = class extends Directive {
  constructor(partInfo) {
    super(partInfo);
    if (!(partInfo.type === PartType.PROPERTY || partInfo.type === PartType.ATTRIBUTE || partInfo.type === PartType.BOOLEAN_ATTRIBUTE)) {
      throw new Error("The `live` directive is not allowed on child or event bindings");
    }
    if (!isSingleExpression(partInfo)) {
      throw new Error("`live` bindings can only contain a single expression");
    }
  }
  render(value) {
    return value;
  }
  update(part, [value]) {
    if (value === noChange || value === nothing) {
      return value;
    }
    const element = part.element;
    const name = part.name;
    if (part.type === PartType.PROPERTY) {
      if (value === element[name]) {
        return noChange;
      }
    } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {
      if (!!value === element.hasAttribute(name)) {
        return noChange;
      }
    } else if (part.type === PartType.ATTRIBUTE) {
      if (element.getAttribute(name) === String(value)) {
        return noChange;
      }
    }
    setCommittedValue(part);
    return value;
  }
};
var live = directive(LiveDirective);

// node_modules/@material/mwc-textfield/mwc-textfield-base.js
var passiveEvents = ["touchstart", "touchmove", "scroll", "mousewheel"];
var createValidityObj = (customValidity = {}) => {
  const objectifiedCustomValidity = {};
  for (const propName in customValidity) {
    objectifiedCustomValidity[propName] = customValidity[propName];
  }
  return Object.assign({ badInput: false, customError: false, patternMismatch: false, rangeOverflow: false, rangeUnderflow: false, stepMismatch: false, tooLong: false, tooShort: false, typeMismatch: false, valid: true, valueMissing: false }, objectifiedCustomValidity);
};
var TextFieldBase = class extends FormElement {
  constructor() {
    super(...arguments);
    this.mdcFoundationClass = foundation_default;
    this.value = "";
    this.type = "text";
    this.placeholder = "";
    this.label = "";
    this.icon = "";
    this.iconTrailing = "";
    this.disabled = false;
    this.required = false;
    this.minLength = -1;
    this.maxLength = -1;
    this.outlined = false;
    this.helper = "";
    this.validateOnInitialRender = false;
    this.validationMessage = "";
    this.autoValidate = false;
    this.pattern = "";
    this.min = "";
    this.max = "";
    this.step = null;
    this.size = null;
    this.helperPersistent = false;
    this.charCounter = false;
    this.endAligned = false;
    this.prefix = "";
    this.suffix = "";
    this.name = "";
    this.readOnly = false;
    this.autocapitalize = "";
    this.outlineOpen = false;
    this.outlineWidth = 0;
    this.isUiValid = true;
    this.focused = false;
    this._validity = createValidityObj();
    this.validityTransform = null;
  }
  get validity() {
    this._checkValidity(this.value);
    return this._validity;
  }
  get willValidate() {
    return this.formElement.willValidate;
  }
  get selectionStart() {
    return this.formElement.selectionStart;
  }
  get selectionEnd() {
    return this.formElement.selectionEnd;
  }
  focus() {
    const focusEvt = new CustomEvent("focus");
    this.formElement.dispatchEvent(focusEvt);
    this.formElement.focus();
  }
  blur() {
    const blurEvt = new CustomEvent("blur");
    this.formElement.dispatchEvent(blurEvt);
    this.formElement.blur();
  }
  select() {
    this.formElement.select();
  }
  setSelectionRange(selectionStart, selectionEnd, selectionDirection) {
    this.formElement.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
  }
  update(changedProperties) {
    if (changedProperties.has("autoValidate") && this.mdcFoundation) {
      this.mdcFoundation.setValidateOnValueChange(this.autoValidate);
    }
    if (changedProperties.has("value") && typeof this.value !== "string") {
      this.value = `${this.value}`;
    }
    super.update(changedProperties);
  }
  setFormData(formData) {
    if (this.name) {
      formData.append(this.name, this.value);
    }
  }
  render() {
    const shouldRenderCharCounter = this.charCounter && this.maxLength !== -1;
    const shouldRenderHelperText = !!this.helper || !!this.validationMessage || shouldRenderCharCounter;
    const classes = {
      "mdc-text-field--disabled": this.disabled,
      "mdc-text-field--no-label": !this.label,
      "mdc-text-field--filled": !this.outlined,
      "mdc-text-field--outlined": this.outlined,
      "mdc-text-field--with-leading-icon": this.icon,
      "mdc-text-field--with-trailing-icon": this.iconTrailing,
      "mdc-text-field--end-aligned": this.endAligned
    };
    return html`
      <label class="mdc-text-field ${classMap(classes)}">
        ${this.renderRipple()}
        ${this.outlined ? this.renderOutline() : this.renderLabel()}
        ${this.renderLeadingIcon()}
        ${this.renderPrefix()}
        ${this.renderInput(shouldRenderHelperText)}
        ${this.renderSuffix()}
        ${this.renderTrailingIcon()}
        ${this.renderLineRipple()}
      </label>
      ${this.renderHelperText(shouldRenderHelperText, shouldRenderCharCounter)}
    `;
  }
  updated(changedProperties) {
    if (changedProperties.has("value") && changedProperties.get("value") !== void 0) {
      this.mdcFoundation.setValue(this.value);
      if (this.autoValidate) {
        this.reportValidity();
      }
    }
  }
  renderRipple() {
    return this.outlined ? "" : html`
      <span class="mdc-text-field__ripple"></span>
    `;
  }
  renderOutline() {
    return !this.outlined ? "" : html`
      <mwc-notched-outline
          .width=${this.outlineWidth}
          .open=${this.outlineOpen}
          class="mdc-notched-outline">
        ${this.renderLabel()}
      </mwc-notched-outline>`;
  }
  renderLabel() {
    return !this.label ? "" : html`
      <span
          .floatingLabelFoundation=${floatingLabel(this.label)}
          id="label">${this.label}</span>
    `;
  }
  renderLeadingIcon() {
    return this.icon ? this.renderIcon(this.icon) : "";
  }
  renderTrailingIcon() {
    return this.iconTrailing ? this.renderIcon(this.iconTrailing, true) : "";
  }
  renderIcon(icon, isTrailingIcon = false) {
    const classes = {
      "mdc-text-field__icon--leading": !isTrailingIcon,
      "mdc-text-field__icon--trailing": isTrailingIcon
    };
    return html`<i class="material-icons mdc-text-field__icon ${classMap(classes)}">${icon}</i>`;
  }
  renderPrefix() {
    return this.prefix ? this.renderAffix(this.prefix) : "";
  }
  renderSuffix() {
    return this.suffix ? this.renderAffix(this.suffix, true) : "";
  }
  renderAffix(content, isSuffix = false) {
    const classes = {
      "mdc-text-field__affix--prefix": !isSuffix,
      "mdc-text-field__affix--suffix": isSuffix
    };
    return html`<span class="mdc-text-field__affix ${classMap(classes)}">
        ${content}</span>`;
  }
  renderInput(shouldRenderHelperText) {
    const minOrUndef = this.minLength === -1 ? void 0 : this.minLength;
    const maxOrUndef = this.maxLength === -1 ? void 0 : this.maxLength;
    const autocapitalizeOrUndef = this.autocapitalize ? this.autocapitalize : void 0;
    const showValidationMessage = this.validationMessage && !this.isUiValid;
    const ariaLabelledbyOrUndef = !!this.label ? "label" : void 0;
    const ariaControlsOrUndef = shouldRenderHelperText ? "helper-text" : void 0;
    const ariaDescribedbyOrUndef = this.focused || this.helperPersistent || showValidationMessage ? "helper-text" : void 0;
    return html`
      <input
          aria-labelledby=${ifDefined(ariaLabelledbyOrUndef)}
          aria-controls="${ifDefined(ariaControlsOrUndef)}"
          aria-describedby="${ifDefined(ariaDescribedbyOrUndef)}"
          class="mdc-text-field__input"
          type="${this.type}"
          .value="${live(this.value)}"
          ?disabled="${this.disabled}"
          placeholder="${this.placeholder}"
          ?required="${this.required}"
          ?readonly="${this.readOnly}"
          minlength="${ifDefined(minOrUndef)}"
          maxlength="${ifDefined(maxOrUndef)}"
          pattern="${ifDefined(this.pattern ? this.pattern : void 0)}"
          min="${ifDefined(this.min === "" ? void 0 : this.min)}"
          max="${ifDefined(this.max === "" ? void 0 : this.max)}"
          step="${ifDefined(this.step === null ? void 0 : this.step)}"
          size="${ifDefined(this.size === null ? void 0 : this.size)}"
          name="${ifDefined(this.name === "" ? void 0 : this.name)}"
          inputmode="${ifDefined(this.inputMode)}"
          autocapitalize="${ifDefined(autocapitalizeOrUndef)}"
          @input="${this.handleInputChange}"
          @focus="${this.onInputFocus}"
          @blur="${this.onInputBlur}">`;
  }
  renderLineRipple() {
    return this.outlined ? "" : html`
      <span .lineRippleFoundation=${lineRipple()}></span>
    `;
  }
  renderHelperText(shouldRenderHelperText, shouldRenderCharCounter) {
    const showValidationMessage = this.validationMessage && !this.isUiValid;
    const classes = {
      "mdc-text-field-helper-text--persistent": this.helperPersistent,
      "mdc-text-field-helper-text--validation-msg": showValidationMessage
    };
    const ariaHiddenOrUndef = this.focused || this.helperPersistent || showValidationMessage ? void 0 : "true";
    const helperText = showValidationMessage ? this.validationMessage : this.helper;
    return !shouldRenderHelperText ? "" : html`
      <div class="mdc-text-field-helper-line">
        <div id="helper-text"
             aria-hidden="${ifDefined(ariaHiddenOrUndef)}"
             class="mdc-text-field-helper-text ${classMap(classes)}"
             >${helperText}</div>
        ${this.renderCharCounter(shouldRenderCharCounter)}
      </div>`;
  }
  renderCharCounter(shouldRenderCharCounter) {
    const length = Math.min(this.value.length, this.maxLength);
    return !shouldRenderCharCounter ? "" : html`
      <span class="mdc-text-field-character-counter"
            >${length} / ${this.maxLength}</span>`;
  }
  onInputFocus() {
    this.focused = true;
  }
  onInputBlur() {
    this.focused = false;
    this.reportValidity();
  }
  checkValidity() {
    const isValid = this._checkValidity(this.value);
    if (!isValid) {
      const invalidEvent = new Event("invalid", { bubbles: false, cancelable: true });
      this.dispatchEvent(invalidEvent);
    }
    return isValid;
  }
  reportValidity() {
    const isValid = this.checkValidity();
    this.mdcFoundation.setValid(isValid);
    this.isUiValid = isValid;
    return isValid;
  }
  _checkValidity(value) {
    const nativeValidity = this.formElement.validity;
    let validity = createValidityObj(nativeValidity);
    if (this.validityTransform) {
      const customValidity = this.validityTransform(value, validity);
      validity = Object.assign(Object.assign({}, validity), customValidity);
      this.mdcFoundation.setUseNativeValidation(false);
    } else {
      this.mdcFoundation.setUseNativeValidation(true);
    }
    this._validity = validity;
    return this._validity.valid;
  }
  setCustomValidity(message) {
    this.validationMessage = message;
    this.formElement.setCustomValidity(message);
  }
  handleInputChange() {
    this.value = this.formElement.value;
  }
  createAdapter() {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.getRootAdapterMethods()), this.getInputAdapterMethods()), this.getLabelAdapterMethods()), this.getLineRippleAdapterMethods()), this.getOutlineAdapterMethods());
  }
  getRootAdapterMethods() {
    return Object.assign({ registerTextFieldInteractionHandler: (evtType, handler) => this.addEventListener(evtType, handler), deregisterTextFieldInteractionHandler: (evtType, handler) => this.removeEventListener(evtType, handler), registerValidationAttributeChangeHandler: (handler) => {
      const getAttributesList = (mutationsList) => {
        return mutationsList.map((mutation) => mutation.attributeName).filter((attributeName) => attributeName);
      };
      const observer2 = new MutationObserver((mutationsList) => {
        handler(getAttributesList(mutationsList));
      });
      const config = { attributes: true };
      observer2.observe(this.formElement, config);
      return observer2;
    }, deregisterValidationAttributeChangeHandler: (observer2) => observer2.disconnect() }, addHasRemoveClass(this.mdcRoot));
  }
  getInputAdapterMethods() {
    return {
      getNativeInput: () => this.formElement,
      setInputAttr: () => void 0,
      removeInputAttr: () => void 0,
      isFocused: () => this.shadowRoot ? this.shadowRoot.activeElement === this.formElement : false,
      registerInputInteractionHandler: (evtType, handler) => this.formElement.addEventListener(evtType, handler, { passive: evtType in passiveEvents }),
      deregisterInputInteractionHandler: (evtType, handler) => this.formElement.removeEventListener(evtType, handler)
    };
  }
  getLabelAdapterMethods() {
    return {
      floatLabel: (shouldFloat) => this.labelElement && this.labelElement.floatingLabelFoundation.float(shouldFloat),
      getLabelWidth: () => {
        return this.labelElement ? this.labelElement.floatingLabelFoundation.getWidth() : 0;
      },
      hasLabel: () => Boolean(this.labelElement),
      shakeLabel: (shouldShake) => this.labelElement && this.labelElement.floatingLabelFoundation.shake(shouldShake),
      setLabelRequired: (isRequired) => {
        if (this.labelElement) {
          this.labelElement.floatingLabelFoundation.setRequired(isRequired);
        }
      }
    };
  }
  getLineRippleAdapterMethods() {
    return {
      activateLineRipple: () => {
        if (this.lineRippleElement) {
          this.lineRippleElement.lineRippleFoundation.activate();
        }
      },
      deactivateLineRipple: () => {
        if (this.lineRippleElement) {
          this.lineRippleElement.lineRippleFoundation.deactivate();
        }
      },
      setLineRippleTransformOrigin: (normalizedX) => {
        if (this.lineRippleElement) {
          this.lineRippleElement.lineRippleFoundation.setRippleCenter(normalizedX);
        }
      }
    };
  }
  async getUpdateComplete() {
    var _a2;
    const result = await super.getUpdateComplete();
    await ((_a2 = this.outlineElement) === null || _a2 === void 0 ? void 0 : _a2.updateComplete);
    return result;
  }
  firstUpdated() {
    var _a2;
    super.firstUpdated();
    this.mdcFoundation.setValidateOnValueChange(this.autoValidate);
    if (this.validateOnInitialRender) {
      this.reportValidity();
    }
    (_a2 = this.outlineElement) === null || _a2 === void 0 ? void 0 : _a2.updateComplete.then(() => {
      var _a3;
      this.outlineWidth = ((_a3 = this.labelElement) === null || _a3 === void 0 ? void 0 : _a3.floatingLabelFoundation.getWidth()) || 0;
    });
  }
  getOutlineAdapterMethods() {
    return {
      closeOutline: () => this.outlineElement && (this.outlineOpen = false),
      hasOutline: () => Boolean(this.outlineElement),
      notchOutline: (labelWidth) => {
        const outlineElement = this.outlineElement;
        if (outlineElement && !this.outlineOpen) {
          this.outlineWidth = labelWidth;
          this.outlineOpen = true;
        }
      }
    };
  }
  async layout() {
    await this.updateComplete;
    const labelElement = this.labelElement;
    if (!labelElement) {
      this.outlineOpen = false;
      return;
    }
    const shouldFloat = !!this.label && !!this.value;
    labelElement.floatingLabelFoundation.float(shouldFloat);
    if (!this.outlined) {
      return;
    }
    this.outlineOpen = shouldFloat;
    await this.updateComplete;
    const labelWidth = labelElement.floatingLabelFoundation.getWidth();
    if (this.outlineOpen) {
      this.outlineWidth = labelWidth;
      await this.updateComplete;
    }
  }
};
__decorate([
  query(".mdc-text-field")
], TextFieldBase.prototype, "mdcRoot", void 0);
__decorate([
  query("input")
], TextFieldBase.prototype, "formElement", void 0);
__decorate([
  query(".mdc-floating-label")
], TextFieldBase.prototype, "labelElement", void 0);
__decorate([
  query(".mdc-line-ripple")
], TextFieldBase.prototype, "lineRippleElement", void 0);
__decorate([
  query("mwc-notched-outline")
], TextFieldBase.prototype, "outlineElement", void 0);
__decorate([
  query(".mdc-notched-outline__notch")
], TextFieldBase.prototype, "notchElement", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "value", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "type", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "placeholder", void 0);
__decorate([
  property({ type: String }),
  observer(function(_newVal, oldVal) {
    if (oldVal !== void 0 && this.label !== oldVal) {
      this.layout();
    }
  })
], TextFieldBase.prototype, "label", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "icon", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "iconTrailing", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], TextFieldBase.prototype, "disabled", void 0);
__decorate([
  property({ type: Boolean })
], TextFieldBase.prototype, "required", void 0);
__decorate([
  property({ type: Number })
], TextFieldBase.prototype, "minLength", void 0);
__decorate([
  property({ type: Number })
], TextFieldBase.prototype, "maxLength", void 0);
__decorate([
  property({ type: Boolean, reflect: true }),
  observer(function(_newVal, oldVal) {
    if (oldVal !== void 0 && this.outlined !== oldVal) {
      this.layout();
    }
  })
], TextFieldBase.prototype, "outlined", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "helper", void 0);
__decorate([
  property({ type: Boolean })
], TextFieldBase.prototype, "validateOnInitialRender", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "validationMessage", void 0);
__decorate([
  property({ type: Boolean })
], TextFieldBase.prototype, "autoValidate", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "pattern", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "min", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "max", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "step", void 0);
__decorate([
  property({ type: Number })
], TextFieldBase.prototype, "size", void 0);
__decorate([
  property({ type: Boolean })
], TextFieldBase.prototype, "helperPersistent", void 0);
__decorate([
  property({ type: Boolean })
], TextFieldBase.prototype, "charCounter", void 0);
__decorate([
  property({ type: Boolean })
], TextFieldBase.prototype, "endAligned", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "prefix", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "suffix", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "name", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "inputMode", void 0);
__decorate([
  property({ type: Boolean })
], TextFieldBase.prototype, "readOnly", void 0);
__decorate([
  property({ type: String })
], TextFieldBase.prototype, "autocapitalize", void 0);
__decorate([
  state()
], TextFieldBase.prototype, "outlineOpen", void 0);
__decorate([
  state()
], TextFieldBase.prototype, "outlineWidth", void 0);
__decorate([
  state()
], TextFieldBase.prototype, "isUiValid", void 0);
__decorate([
  state()
], TextFieldBase.prototype, "focused", void 0);
__decorate([
  eventOptions({ passive: true })
], TextFieldBase.prototype, "handleInputChange", null);

// node_modules/@material/mwc-textfield/mwc-textfield.js
import { styles as styles2 } from "/home/euge/Documentos/Pasant\xEDa/Chatbot/Lista Blanca/whitelist-front/node_modules/@material/mwc-textfield/mwc-textfield.css.js";
var TextField = class TextField2 extends TextFieldBase {
};
TextField.styles = [styles2];
TextField = __decorate([
  customElement("mwc-textfield")
], TextField);
export {
  TextField
};
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
//# sourceMappingURL=@material_mwc-textfield.js.map
